#
# Copyright (c) 2003-2019 University of Chicago and Fellowship
# for Interpretations of Genomes. All Rights Reserved.
#
# This file is part of the SEED Toolkit.
#
# The SEED Toolkit is free software. You can redistribute
# it and/or modify it under the terms of the SEED Toolkit
# Public License.
#
# You should have received a copy of the SEED Toolkit Public License
# along with this program; if not write to the University of Chicago
# at info@ci.uchicago.edu or the Fellowship for Interpretation of
# Genomes at veronika@thefig.info or download a copy from
# http://www.theseed.org/LICENSE.TXT.
#

package rs;

    use strict;
    use warnings;
    use Data::Dumper;

=head1 DESC

This package contains methods for constructing, accessing, and manipulating representative genome sets.

=head2 Special methods

=head3 kmers

    $seq_1->{kmers} = kmers($seq_1->{sequence}, 8)

Given a sequence, return a pointer to a hash of kmer presences, i.e. all kmers appearing in the sequences kave value 1.

=over 4

=item sequence

A string corresponding to a sequence of DNA or amino acid characters. Sequences are processed as-is, so any substitutions of ambiguity characters, case conversions, etc., should happen before kmers() is called.

=item kmer length

An integer representing the kmer size to compute. Defaults to 8-mers.

=cut

sub kmers{
    my ($seq, $opts) = @_;

    my $k   = $opts->{'k'} // 8; # default 8-mers
    my $len = length $seq;
    my $kmers;

    # Pull out all substrings into hash
    for my $i (0..$len-$k){
        $kmers->{substr $seq, $i, $k} = 1;
    }

    return $kmers;
}

=head3 sim

    my $similarity_score = sim($seq_1->{kmers}, $seq_2->{kmers});

Compute a similarity score based on number of kmers in common between two kmer hashes. Note that this function assumes two hashes are using the same k, and does not check for it; it simply returns the number of keys in common two hashes share.

=over 4

=item hash 1

A hash of {kmer => 1} instances generated by the rs::kmer() method.

=item hash 2

A hash of {kmer => 1} instances generated by the rs::kmer() method.

=cut

sub sim{
    my ($hash1, $hash2) = @_;
    my @keys1 = keys %$hash1;

    my $similarity = 0;

    # Check hash2 for entries matching keys of hash1
    for my $key (@keys1){
        if (defined $hash2->{$key}){
            $similarity++;
        }
    }

    # Only interested in number of kmers in common
    return $similarity;
}

=head3 read_in

    my $rows = read_in('/path/to/file');

Given a path to a table of inputs with columns (genome, score, sequence), returns a pointer to a hash with structure $hash->{'genome'} => {score'=>..., 'seq'=>..., 'line'=>...}.

=over 4

=item table

A hash, as generated by rs::read_in(), representing a table with columns (genome, score, sequence). 

=cut

sub read_in{
    # Process input table
    my ($path) = @_;

    open my $fh, '<', $path;

    my %rows;
    my $line_num = 0;
    while (my $line = <$fh>){
        # remove header
        if ($line =~ m/genome/i){ next }

        # process input
        chomp $line;
        my ($gen, $score, $seq) = split "\t", $line;

        # Generate hash from all lines
        $rows{$gen} = { 'score' => $score,
                        'seq'   => $seq,
                        'line'  => $line_num++};
    }
    close $fh;

    return \%rows;
}

=head3 rep_set

    my $rep_set = rep_set('/path/to/file', 0, 8, 100, 1)

=over 4

=item path

A string representing a path to a file with columns (genome, score, sequence) for some universal protein.

=item load

A boolean variable. If set to 0, rs::rep_set() will check each row it reads for similarity against members of the representative set, thereby ensuring all members of the set are sufficiently distant from each other. If set to 1, it will skip this step, which saves a lot of time when loading the output of a previous rs::rep_set() computation.

=item kmer length

An integer representing the kmer size to compute. Defaults to 8-mers.

=item cutoff

An integer representing the k-mer similarity score used as a basis for judging two genomes are "too close" to both be in the representative set. Defaults to 100.

=item verbose

Prints "genome  score   sequence" for each element of the representative set unless set to 0.

=cut

sub rep_set{
    my ($rows, $opts) = @_;

    my $load    = $opts->{'load'}       // 0;
    my $cutoff  = $opts->{'cutoff'}     // 100;
    my $print   = $opts->{'verbose'}    // 0;   # Default is not to print

    # Pare down to representatives
    my @gens = keys %$rows;

    # Sort by order they appeared
    @gens = sort {$rows->{$a}->{'line'} <=> $rows->{$b}->{'line'}} @gens;
    my $reps;
    for my $gen (@gens){
        # Part 1: generate hash table of k-mers
        my $kmers = kmers $rows->{$gen}->{'seq'}, $opts;

        # Part 2: check for representatives
        if ($load) {
            $reps->{$gen} = {   'kmers' => $kmers,
                                'seq'   => $rows->{$gen}->{'seq'},
                                'score' => $rows->{$gen}->{'score'}};
        }
        else{
            my $max_sim = 0;
            for my $key (keys %$reps){
                my $key_kmers   = $reps->{$key};
                my $sim         = sim($kmers, $reps->{$key}->{'kmers'});
                if ($sim > $max_sim)    { $max_sim = $sim }
                if ($sim >= $cutoff)    { last }
            }
            if ($max_sim < $cutoff){
                $reps->{$gen} = {   'kmers' => $kmers,
                                    'seq'   => $rows->{$gen}->{'seq'},
                                    'score' => $rows->{$gen}->{'score'}};
            }
        }
        if ($print and $reps->{$gen}){
            my $seq     = $reps->{$gen}->{'seq'};
            my $score   = $reps->{$gen}->{'score'};
            print "$gen\t$score\t$seq\n";
        }
    }
    return $reps;
}

=head3 closest_genome

    my $closest_genome = closest_genome($genome1->{'sequence'}, $reps)

Given a sequence and a hash to a table of representatives, returns the ID of the single most similar representative. 

=over 4

=item sequence

A string representing a sequence to be compared against the representative set.

=item representatives

A hash of representatives and their kmers generated by rs::rep_set()

=cut

sub closest_genome{
    my ($seq, $reps, $opts) = @_;

    my $kmers = kmers($seq, $opts);
    my $best_score = 0;
    my $closest;

    for my $rep (keys %$reps){
        my $n = sim $kmers, $reps->{$rep}->{'kmers'};
        if ($n > $best_score){
            $best_score = $n;
            $closest = $rep;
        }
    }
    return [$closest, $best_score];
}

=head3 assign_reps

    assign_reps($genomes, $representatives)

Given a path to a table of candidate genomes (to be assigned representatives) and a table of precomputed representatives (generated by rs::rep_set() function), prints "genome  representative  similarity" table, where the representative is the most similar genome in the representative set, computed by rs::closest_genome().

=over 4

=item candidates_path

A path to a table of candidates with rows (genome, score, sequence). Each genome in this table gets assigned a representative from the table in reps_path.

=item reps_path

A path to a table of representatives with rows (genome, score, sequence). Each genome in candidates_path gets compared against each of these representatives.

=back 

=cut

sub assign_reps{
    my ($genomes, $reps, $opts) = @_;

    my $print = $opts->{'verbose'}  // 0;
    # my $load = $opts->{'load'}      // 0;

    my @keys = keys %$genomes;
    my $l   = scalar @keys;
    my $rep_assignments;
    my $rep_sets;

    for my $key (@keys){
        my $seq             = $genomes->{$key}->{'seq'};
        my ($rep, $score)   = @{closest_genome($seq, $reps, $opts)};

        $rep_assignments->{$key}->{'rep'}   = $rep;
        $rep_assignments->{$key}->{'score'} = $score;

        $rep_sets->{$rep}->{$key} = $genomes->{$key};

        if ($print){ print "$key $rep    $score\n" }
    }
    return ($rep_assignments, $rep_sets);
}

sub load_rep_assignment{
    my ($path, $genomes) = (@_);
    open my $fh, '<', $path;

    my $rep_assignments;
    my $rep_sets;
    while (<$fh>){
        chomp $_;
        my ($genome, $rep, $score) = split "\t", $_;

        $rep_assignments->{$genome}->{'rep'} = $rep;
        $rep_assignments->{$genome}->{'score'} = $score;

        if ($genomes){
            $rep_sets->{$rep}->{$genome} = $genomes->{$genome}
        }
    }
    return ($rep_assignments, $rep_sets);
}




1;
